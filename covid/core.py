# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['setDefaults', 'ROOT', 'CONFIRMED', 'DEATHS', 'RECOVERED', 'getToday', 'getYesterday', 'procDataframe',
           'procUrl', 'getCountriesDailyReport', 'plotCountriesDailyReport', 'plotCountryDailyReport',
           'getTimeSeriesConfirmed', 'getTimeSeriesDeaths', 'getTimeSeriesRecovered', 'procTimeSeriesDataframe',
           'procTimeSeries', 'procTimeSeriesDeaths', 'procTimeSeriesConfirmed', 'plotCountriesTimeSeries',
           'getCountriesDailyReportFromAPI', 'plotCountriesDailyReportFromAPI', 'getCategoryByCountryFromAPI',
           'plotCategoryByCountryFromAPI']

# Cell
import typing
from typing import List, Callable
import requests
import datetime
from datetime import date
import io
import os
from io import StringIO
import urllib.request
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import altair as alt

# Cell
def setDefaults(figsize=(18,9)):
    sns.set_style("dark")
    sns.set(rc={'legend.fontsize':14,
                'xtick.labelsize':14,
                'ytick.labelsize':14,
                'axes.labelsize':16,
                'axes.titlesize':18,
                'figure.figsize':figsize,
               })

# Cell
ROOT      = 'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data'
CONFIRMED = 'time_series_covid19_confirmed_global.csv'
DEATHS    = 'time_series_covid19_deaths_global.csv'
RECOVERED = 'time_series_19-covid-Recovered.csv'

# Cell
getToday: Callable[[None], str] = lambda: date.today().strftime('%m-%d-%Y')
getYesterday: Callable[[None], str] = lambda: (date.today() - datetime.timedelta(days = 1)).strftime('%m-%d-%Y')

# Cell
def procDataframe(csv: str) -> pd.DataFrame:
    ''' Convert input csv data or file to a pandas dataframe. '''
    assert(csv)
    df = pd.read_csv(csv)
    try:
        df['Province/State'].fillna('',inplace=True)
    except:
        df['Province_State'].fillna('',inplace=True)
    df.fillna(0, inplace=True)
    cols = df.columns.to_list()
    if 'Last Update' in cols:
        df['Last Update'] = df['Last Update'].apply(pd.to_datetime)
    if 'Last_Update' in cols:
        df['Last_Update'] = df['Last_Update'].apply(pd.to_datetime)
    return df

def procUrl(url: str, download: bool, localfile: str=None, force: bool=False, verbose: bool=False) -> pd.DataFrame:
    ''' Optionally download then process csv data or file at url converting it to a pandas dataframe. '''
    assert(url)
    if download:
        if os.path.exists(localfile) and not force:
            verbose and print(f'"{localfile}" already exists so will not overwrite')
        else:
            verbose and print(f'Downloading "{localfile}" from "{url}"...')
            urllib.request.urlretrieve(url, localfile)
        return procDataframe(localfile)
    else:
        s = requests.get(url).content
        return procDataframe(io.StringIO(s.decode('utf-8')))

# Cell
def getCountriesDailyReport(day: str, download: bool=False, force: bool=False) -> pd.DataFrame:
    assert(len(day))
    url = f'{ROOT}/csse_covid_19_daily_reports/{day}.csv'
    localfile = f'{day}.csv'
    return procUrl(url, download, localfile, force)

def plotCountriesDailyReport(df: pd.DataFrame, topN: int=10, color: str='y', kind: str='Confirmed', visualisation: str='matplotlib') -> None:
    if visualisation == 'altair':
        sdf = df.groupby('Country_Region')[kind].sum().sort_values(ascending=False)[:topN]
        keys = sdf.keys().to_list()
        vals = sdf.to_list()
        data = []
        for k,v in zip(keys,vals):
            data.append({'Country':k, kind: v})
        sdf = pd.DataFrame(data)
        bar_chart = alt.Chart(sdf).mark_bar(size=30).encode(
            x=alt.X('Country',sort='-y'),
            y=kind,
            color=alt.value(color),
            opacity=alt.value(0.9),
        ).properties(
            width=1000,
            height=450
        )
        bar_chart.display()
    else:
        fig, ax = plt.subplots()
        ax = df.groupby('Country_Region')[kind].sum().sort_values(ascending=False)[:topN].\
          plot(ax=ax, kind='bar', color=color, stacked=False, figsize=(18,9))
        ax.set_ylabel(kind, size=14)
        ax.set_xlabel('Country', size=14)
        ax.set_title(f'Total {kind} by top {topN} countries as of {getYesterday()}', size=18)
        plt.show()

def plotCountryDailyReport(df: pd.DataFrame, country: str, topN: int=10, color: str='orange', kind: str='Confirmed', visualisation: str='matplotlib') -> None:
    if visualisation == 'altair':
        sdf = df[df['Country_Region'] == country].groupby('Province_State')[kind].sum().sort_values(ascending=False)[:topN]
        keys = sdf.keys().to_list()
        vals = sdf.to_list()
        data = []
        for k,v in zip(keys,vals):
            data.append({'Province_State':k, kind: v})
        sdf = pd.DataFrame(data)
        bar_chart = alt.Chart(sdf).mark_bar(size=30).encode(
            x=alt.X('Province_State',sort='-y'),
            y=kind,
            color=alt.value(color),
            opacity=alt.value(0.9),
        ).properties(
            width=1000,
            height=450
        )
        bar_chart.display()
    else:
        ax = df[df['Country_Region'] == country].groupby('Province_State')[kind].sum().sort_values(ascending=False)[:topN].\
          plot(kind='bar', color=color, stacked=False, figsize=(18,9))
        ax.set_ylabel(kind, size=14)
        ax.set_xlabel('Country', size=14)
        ax.set_title(f'Total {kind} for top {topN} regions of {country} as of {getYesterday()}', size=18)

# Cell
def getTimeSeriesConfirmed(download: bool=False, force: bool=False) -> pd.DataFrame:
    url = f'{ROOT}/csse_covid_19_time_series/{CONFIRMED}'
    localfile = 'time_series_19-covid-Confirmed.csv'
    return procUrl(url, download, localfile, force)

def getTimeSeriesDeaths(download: bool=False, force: bool=False) -> pd.DataFrame:
    url = f'{ROOT}/csse_covid_19_time_series/{DEATHS}'
    localfile = 'time_series_19-covid-Deaths.csv'
    return procUrl(url, download, localfile, force)

def getTimeSeriesRecovered(download: bool=False, force: bool=False) -> pd.DataFrame:
    url = f'{ROOT}/csse_covid_19_time_series/{RECOVERED}'
    localfile = 'time_series_19-covid-Recovered.csv'
    return procUrl(url, download, localfile, force)

# Cell
def procTimeSeriesDataframe(r: List) -> pd.DataFrame:
    sdf = pd.DataFrame(r)
    sdf['day'] = sdf['day'].apply(pd.to_datetime)
    sdf.set_index('day', drop=True, inplace=True)
    return sdf

def procTimeSeries(df: pd.DataFrame, kind: str) -> pd.DataFrame:
    r = []
    countries = df.groupby('Country/Region')
    cols = df.columns.to_list()
    for country, group in countries:
        total = []
        for row_index, row in group.iterrows():
            rvals = row.to_list()
            if not len(total):
                total = rvals[4:]
                #print('first',total)
            else:
                #print('next',rvals[4:])
                total = [a+b for a, b in zip(total, rvals[4:])]
        for a, b in zip(cols[4:], total):
            r.append({'day':a, 'country':country, kind:b})
    return procTimeSeriesDataframe(r)

procTimeSeriesDeaths: Callable[[pd.DataFrame], pd.DataFrame] = lambda: procTimeSeries(getTimeSeriesDeaths(download=True, force=True), 'Deaths')
procTimeSeriesConfirmed: Callable[[pd.DataFrame], pd.DataFrame] = lambda: procTimeSeries(getTimeSeriesConfirmed(download=True, force=True), 'Confirmed')
#procTimeSeriesRecovered: Callable[[pd.DataFrame], pd.DataFrame] = lambda: procTimeSeries(getTimeSeriesRecovered(download=True, force=True), 'Recovered')

# Cell
def plotCountriesTimeSeries(df: pd.DataFrame, countries: List, kind: str, visualisation='matplotlib') -> None:
    if visualisation == 'altair':
        print("Not supported!")
    else:
        fig, ax = plt.subplots()
        for country in countries:
            ax = df[df['country'] == country].plot(ax=ax, y=kind, kind='line', figsize=(18,9))
        ax.set_ylabel('Count', size=14)
        ax.set_xlabel('Day', size=14)
        ax.set_title(f'{kind} in {countries} as of {getYesterday()}', size=18)
        ax.legend(ax.get_lines(),countries)
        plt.show()

# Cell
def getCountriesDailyReportFromAPI(normalised=False):
    url = 'https://api.covid19api.com/summary'
    if normalised:
        df = pd.DataFrame(requests.get(url).json().get('Countries'))
        df.Country.replace({'Iran (Islamic Republic of)': 'Iran', 'Korea, South': 'South Korea'},inplace=True)
        cols = df.columns.to_list()
        sdf = df.groupby('Country')[cols[2:]].apply(sum).reset_index()
        sdf = sdf.sort_values(by=['TotalConfirmed'], ascending=False)
    else:
        sdf = pd.DataFrame(requests.get(url).json().get('Countries')).\
          sort_values(by=['TotalConfirmed'], ascending=False)
    return sdf

def plotCountriesDailyReportFromAPI(normalised=False, visualisation='matplotlib'):
    sdf = getCountriesDailyReportFromAPI(normalised)
    if visualisation == 'altair':
        print("Not supported!")
    else:
        _ = sdf[sdf.TotalDeaths > 10].plot(kind='bar', x='Country', y=['TotalConfirmed', 'TotalDeaths'],\
          color='yr', stacked=True, figsize=(18, 9)).set_title('Covid-19 cases and deaths', size=18)

def getCategoryByCountryFromAPI(category, country, color):
    url = f'https://api.covid19api.com/total/country/{country}/status/{category.lower()}'
    sdf = pd.DataFrame(requests.get(url).json())
    sdf['Date'] = sdf['Date'].apply(pd.to_datetime)
    return sdf

def plotCategoryByCountryFromAPI(category, country, color='orange', visualisation='matplotlib'):
    sdf = getCategoryByCountryFromAPI(category, country, color)
    if visualisation == 'altair':
        line_chart = alt.Chart(sdf).mark_line().encode(
            x='Date:T',
            y='Cases',
            color=alt.value(color)
        ).properties(
            width=1000,
            height=450
        )
        line_chart.display()
    else:
        sdf.plot(kind='line', x='Date', y='Cases', color=color, figsize=(18, 9)).\
          set_title(f'Covid-19 {category} in {country}', size=18)